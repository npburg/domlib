#labels Phase-Requirements,Phase-Design,Featured
= Domlib Design Doc =
== Classes ==
  * *AI*: The AI class is the base class for any AI that is written by an AI developer. The default implementation will be provided in the DeafultAI so AI developers can extend this class if they do not want to override every interface.
  * *ICard* - The ICard class provides the public interface to the AI to gain public information about the card such as the cost, plus action, etc, (note, some information may vary based on the context of the player for example PhilosopherStoneCard’s cost is determined by the size of the draw pile and discard pile.)
  * *Card* – The Card class is derived from the ICard class to provide the AI information through that interface and the Card class serves as the base class for each specific card class in the game. (i.e. MoatCard, GoldCard, EstateCard, etc.) The Card class provides the basic implementation for the ICard class interfaces as well as the basic implementation for the phase it supports. The cards that derive from this class are expect to implement the phase functions to implement the behavior per phase if it is different than the default implementation..
  * *CardFactory* – The Card class uses to Singleton pattern to prevent the creation of more than one card instance to be instantiated. The CardFactory manages the creation and distribution of the different cards for the Card class. It is a nested class of the Card class and a static member so it is always available and when the program exits, the CardFactory will clean up the Cards it generated.
  * *IEngine* – The IEngine class provides the interface for the AI to request information about the state of the game.
  * *Engine* – The engine manages the list of players, contains the main loop for playing the game and holds the SupplyPileManager and any global state such as the TradeRouteMat or the TrashPile.
  * *IGame* – The IGame class provides the public interface for the Game class.
  * *Game* – The game class contains the engine and provides the link from the application to the engine for setting up the game and registering the AIs. The reason this is separated from the Engine itself is because each AI is provide a reference to the IEngine to get the current state of the game engine to make decisions. The Engine also needs to provide a register AI function to the application; however, if this was part of the IEngine interface then an AI, while in the middle of the game, could register another AI or request the supply piles to be randomized again or any other changes to the game. The IGame/Game class provide the interface for the app to setup the game, while IEngine/Engine provide the current state of the game to the AI while the game is being played.
  * *IPlayer* – The IPlayer class provides the basic interface for the AI to gain public information about a Player. This does not provide any private information about the Player the AI is registered with.
  * *IPlayerSelf* – The IPlayerSelf class provides the basic interface for the AI to gain public and private information about a Player. This still does not provide information a player is not allowed to know about itself such as the contents of the draw pile.
  * *Player* – The Player class manages all the lists, piles, mats and turn state that represent a player in the game.
  * *ITreasure* – The ITreasure class provides the AI access to the Treasure classes external interface. The Treasure class is not provided externally since that would enable an AI to rewrite the Treasure class to modify it’s behavior.
  * *Treasure* – The Treasure class represent the complex value of currency in the game (coins and potions). This class provides overrided operators such as (+, -, ==, <, etc.). 
  * *SupplyPile* – The SupplyPile class manages the number of supply cards in a pile, the number of embargo tokens and trade route tokens and any other state of an individual pile.
  * *SupplyPileManager* – The SupplyPileManager class manages all the supply piles in the game and some basic functionality the Engine such as helping determine the victory condition or setting up the piles used in the game.
==Turn Phases==
  * *Start of turn* – The turn is initialized with setting the number of actions, buys and treasure to start with and clears turn lists (except Duration List, any others???) The AI is notified of the start of the player’s turn to save any state that is cleared at the start of the turn.
  * *Duration Phase* – All the Duration card in the duration list are processed for their duration effects. The cards in this list where places here during the previous turn’s Cleanup phase.
  * *Action Phase* – The AI is requested to play Action cards from Hand one at a time until there are no more actions left this turn or no more Action cards in Hand or the AI returns the NullCard to indicate it does not wish to play any more action cards. Cards which the AI requests to play are checked against the cards in Hand, then placed into the In-Play list, the number of actions for the player’s turn is decremented and the number of actions cards played for the player’s turn is incremented and then the card is played by the Player.
  * *Treasure Phase* – The AI is requested to play Treasure cards from Hand one at a time until they have not more Treasure cards in Hand or the AI returns the NullCard to indicate it does not wish to play any more actions cards. This phase is needed for the new Prosperity Treasure cards since the order the cards are played matter due to the effects of the Treasure cards. As the cards are played, they also return the value of the treasure card at the state in the game at the time the individual treasure card is played to sum up the buying power for the BuyPhase.
  * *Buy Phase* – The AI is requested to buy a card from supply for which they have purchasing power until the player has no more “buys” or no more purchasing power or the AI return the NullCard indicating it does not wish to purchase another card.
  * *Cleanup Phase* – The cards in the InPlayList are processed to preform any special Cleanup phase actions, then the DurationList is cleared and any Duration cards in the InPlayList are put into the DurationList and the remaining cards in the InPlayList and Hand are discarded. Finally the player draws 5 cards (or draws 3 cards if Output is in play.)
==Player / Engine Containers==
  * *Deck* – all cards in the players possession including draw pile, hand, discard, in-play, duration, island mat, native village mat, etc. The count and contents of this list is not available to any player until the game is over.
  * *DrawPile* – all cards in the draw pile and it is the source of any draw function. When this pile is empty, the cards from the DiscardPile are randomized and transfer to this pile. The count is available to any player (???) and contents is not available to any player.
  * *Hand* – the list of cards in hand which are typically drawn from the DrawPile but can be gained from other sources. The count is available to any player but the contents are only available to the owning player.
  * *InPlayList* – is a list of Action cards that the player has played during the action phase. The count and cards are publicly known.
  * *DiscardPile* – is the list of card which were previously InPlay or gain from another source such as when bought. The count and contents of this pile is not known by any player. (might add the ability to see the top card of this pile.)
  * *RevealedList* – is a list of cards which are temporary revealed to other players and put back to the source. These cards are not InPlay; however, they may come from the SetAside list. A Moat revealed as part of a reaction is in this list but not in the SetAsideList and is returned to hand. The whole hand is put in this list if Bureaucrat is played but the player has no victory cards.
  * *SetAsideList* – is a list of cards that are set aside as a function of implementing the action of a card and typically come from the draw pile. Library will draw cards from the deck and set them aside. Since these cards are face up then they should be also put in the RevealList. The SetAsideList should be managed by the action card where as the RevealedList is managed by the player.
  * *BuyList* – is a list of cards bought by a player and its count and co
  * *DurationList* – is a list of card that are is duration from the previous turn. When a duration card is played it is in the InPlayList until the cleanup phase in which case it is moved to the DurationList. At the start of the next turn, any cards in the DurationList are played for their duration effect and then at the start of the cleanup phase are moved into the DiscardPile. The count and contents of this list is publicly known.
  * *HavenList* – is a special list to hold the cards that Haven plays. During the duration phase any cards in this list are put into the Hand.
  * *TrashPile* is a list of cards that have been trashed. The count and contents of this list is public information.
  * *NativeVillageMat* this is a list of cards placed on the NativeVillageMat. The count and contents of the mat only known by the player.
  * *IslandMat* is a list of cards placed on the island mat. The count and contents of the mat is public information.
  * *PirateShipMat* is a count of pirate coins. This number is public information.
  * *SupplyPile* is the a pile of a supply card (kingdom cards, treasure cards victory cards) in the game. The count and contents is publicly known. In addition, the SupplyPile contains a count of embargo tokens and TradeTokens which are also public information.
  * *TradeRouteMat* is a count of TradeTokens which is public information. Unlike most of the other lists, piles and mats, this mat is managed by the Engine class instead of the Player class since it is a shared mat.
  * *VictoryPointMat* (called player mat in the rules) is a count of the VictoryTokens (called <shield symbol> tokens in the rules). The count is publicly known.
==Function Naming Convention==
  * *GainCardxxx*( Card ) – this prefix indicates that the card should be taken from a supply pile and put into the post fix destination. If the supply pile is empty then this is a no-op. It is up to the caller to know if it is valid to call this function if the supply pile is empty.
    * For example: GainCardInHand( card ) this takes a card from the supply pile and put it in the Hand list.
  * *OnGainACardxxx*( Cost ) – this prefix indicates that the player’s AI should be queried about a card from supply to gain and then place the card in the destination postfix.
  * *PutCardxxx*( Card ) – this prefix indicates that the card should simply put into the postfix destination without knowing the source. It is up to the caller to handle the bookkeeping for the source of this card. 
    * For example: PutCardInTrash( card ) this puts a reference to the card in the trash pile without knowing where it came from but this is just an example since TrashCard( card ) is the same as PutCardInTrash( card ).
  * *TrashCardxxx*( Card ) – this prefix indicates that the card should go to the postfix source. If there is no postfix source then the card is simply trashed and it is up to the caller to handle the bookkeeping of the source.
    * For example: TrashCardFromHand( card ) will take the card from the Hand list and put it in the TrashPile
==AI Class==
The AI class will contain the logic that drive the player classes decisions. There is an Interface class the AI will derive from and will need to implement the interface functions to work correctly.
==AI Interfaces==
TODO: Add description of the Bridge pattern and it’s use with the AI interfaces.
==Card Class==
All cards are derived from the Card class and implement needed functions. The base class will have the default implementation since most operations will be common. The class will have any helper functions for common operations such as AttackCard. The class will also have a reference to the GameEngine to query the players or modify game state. The Card class will also implement AI interface version of Card which provides the user access to some but not all of the class functions. The Card class also implements a singleton model such that there is a private constructor for the class and all derived class, there is a static GetCard method to get a copy a card from a factory by passing in the CARDID. 

====Action Card Execution====
Each card has a pointer to the game engine enabling the card to execute it’s own instruction. The game engine manages the players (piles, hands, mats, tokens etc) and the deck (piles) and any tokens.

By default, any action card played, decrements the actions by 1 and the card is removed from the player’s hand to the “in-play” list. Duration cards moved from in-play to duration list in clean-up phase.

====AttackCard Helper function====
Instead of writing the same loop to attack players for each attack write a single function which takes in the attack card played and a flag to indicate is self attack is possible (i.e. Spy)
{{{
For each (other) player
{
    If(player does not have Lighthouse in DurationList)
    {
        reactionCard = player->GetReaction( AttackCard )
        if( reactionCard != Moat)
        {
            reactionCard.Reaction( AttackCard, player );
            AttackCard.Attack()
        }
    }
}
}}}

====Reaction Cards====
If an attack occurs the player is queried for a reaction card from hand.
The card returned then has card.Reaction( AttackCard ) function called to perform a reaction action.

====Card::GainACard() Helper function====
This should call player::GainACard() function in the player but instead of having a card directly call this function it should call the Card::GainACard() which include checks to make sure play gained a valid card
{{{
Card::GainACard()
{
    Card = player.GainACard();
    if(Card in stock)
    {
        Put card in player’s discard pile
    }
    // do nothing
}
}}}
This function always puts the card into the discard pile. If the card is suppose to go into the draw pile or hand then a more explicit function should be called.

====Cleanup function====
This allows the card to perform any special actions on the cards in the in-play list (including itself) before the in-play is moved to the discard pile.
==Game Class==
TODO: Add info
==Engine Class==
The engine class will contain the list of players, the supply piles and any other general state about the game. The engine will also have functions for running the game such as the different phases of a turn.

The Engine will contain a Supply Pile Manager which has all the piles of a given game and the interfaces to manage the piles. The Supply Pile Manager will also handle setting up the piles for different game types (preloaded, random, mixed/pure sets, etc.) The individual piles will use the Pile class which manages the card in the pile, number of cards available, and add additional state such as embargos or trade route tokens.
==SupplyPile Class==
TODO: Add info
==SupplyPileManager Class==
TODO: Add info
==Player Class==
The player class will contain the various piles/mats/etc (Discard, Draw, Hand, Duration, Reveal, Island Mat, NativeVillage Mat, etc.). It will also log actions of the player and hand the actions requested to/from the AI or Card.
==Treasure Class==
Treasure struct handles the complex system of currency in the game (coins + potions) since currency is no longer simply coins, it cannot be represented by a single integer.
==Common Cards==
====Copper::OnTreasureValue()====
  * Return 1 + the number of Coppersmiths in the player’s InPlayList.
====Silver====
  * Default behavior
====Gold====
  * Default behavior
====Estates====
  * Default behavior
====Duchy====
  * Default behavior
====Province====
  * Default behavior
====Curse====
  * Default behavior